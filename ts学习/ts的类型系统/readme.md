# TypeScript 的类型系统
TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统

- js的基本类型(ts继承了)
boolean
string
number
bigint
symbol
object
undefined
null
以上都是小写，一些大写在js中是内置的对象。


# 包装对象类型
boolean，string，number，bigint，symbol都有对应得包装对象。即在需要的时候，会自动产生对象。例如："hello".charAt(1); // 'e'
boolean，string，number都有自己的构造函数，在执行上面的函数之后会得到相应的包装对象，但是一定得作为构造函数，被new作用。
bigint和symbol没有对应得构造函数。所以不能得到包装对象，只能得到原始值。

### 包装对象类型与字面量类型
由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况
"hello"; // 字面量
new String("hello"); // 包装对象

为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。
Boolean 和 boolean
String 和 string
Number 和 number
BigInt 和 bigint
Symbol 和 symbol
大写和小写有什么区别呢？大写类型涵盖了包装对象和字面量，但是小写只涵盖字面量。

 ###  建议
 建议只使用小写类型，不使用大写类型。
 因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。
 而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错

### Object 类型与 object 类型
TypeScript 的对象类型也有大写Object和小写object两种。
### Object
- 大写的Object类型代表了javascript语言里面的广义对象，所有可以转成对象的值，都是Object类型，包含了除了null和undefind之外的所有值。
- 空对象{}是Object类型的简写形式，所以常用{}代替

### object 类型
- 小写的object类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。
- 大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型object，不使用大写类型Object。
你想想，用ts就是为了缩小数据的范围，给数据一个限定。而大写的Obeject涵盖几乎所有的类型，从这个层面来说，少用Object类型。
- 注意，无论是大写的Object类型，还是小写的object类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中

### 值类型
typeScript 规定，单个值也是一种类型，称为“值类型”。
- TypeScript 推断类型时，遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。
其实也可以这么认为，毕竟const声明的变量不能修改,而且必须赋值，与js高度一致，所以我认为值类型是为const创立的

- 值类型可能会出现一些很奇怪的报错。const h: 5 = 4 + 1; // 报错，因为number是父类型，5是子类型，父类型不能赋值给子类型。
这也是ts一个重要的点，子类型可以赋值给父类型而父类型不能赋值给子类型。

### 联合类型
- 联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。联合类型A|B表示，任何一个类型只要属于A或B，就属于联合类型A|B。
但是这是属于扩大了范围。
- 联合类型可以与值类型相结合，表示一个变量的值有若干种可能。
- 前面提到，打开编译选项strictNullChecks后，其他类型的变量不能赋值为undefined或null。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。

### 类型缩小
- 如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。

### 交叉类型
- 交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号&表示。交叉类型A&B表示，任何一个类型必须同时属于A和B，才属于交叉类型A&B，即交叉类型同时满足A和B的特征。
- 交叉类型的主要用途是表示对象的合成。


### type 命令
- type命令用来定义一个类型的别名。
- 别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。别名不允许重名。
- 别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部
- 别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。
  type命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。

### typeof运算符
- JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。
- 同一段代码可能存在两种typeof运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。
- JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。由于编译时不会进行 JavaScript 的值运算，所以 TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。
- 另外，typeof命令的参数不能是类型。

### 类型的兼容
- TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。
- typeScript 为这种情况定义了一个专门术语。如果类型A的值可以赋值给类型B，那么类型A就称为类型B的子类型（subtype）。在上例中，类型number就是类型number|string的子类型。TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。其实也可以说子类的范围更小，更精确，存在包含关系。